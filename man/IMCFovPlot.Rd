% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/IMCFovPlot.R
\name{IMCFovPlot}
\alias{IMCFovPlot}
\title{Plot feature overlays on an IMC FOV (Seurat v5)}
\usage{
IMCFovPlot(
  obj,
  features,
  assay = Seurat::DefaultAssay(obj),
  layer = c("asinh", "scale.data", "data", "counts"),
  boundaries = c("segmentation", "centroids"),
  combine = c("max", "mean", "sum", "rgb", "stack"),
  normalize = c("none", "minmax"),
  transform = c("none", "log1p", "sqrt"),
  pt_size = 0.6,
  alpha = 0.9,
  colors = NULL,
  alpha_range = NULL,
  stack_rescale_alpha_by_n = FALSE,
  stack_alpha_gamma = 1,
  limits = NULL,
  export_path = NULL,
  dpi = 300,
  verbose = TRUE,
  rebuild_seg_if_missing = TRUE,
  spatial_rotate_k = 0L,
  rotate_center = c(NA_real_, NA_real_)
)
}
\arguments{
\item{obj}{A Seurat object for a single FOV (as created by \code{\link{LoadIMCSegmented}}).}

\item{features}{Character vector of feature names in \code{assay} (friendly names produced by the loader, e.g., \code{"141Pr"}).}

\item{assay}{Assay to pull data from (default: \code{Seurat::DefaultAssay(obj)}).}

\item{layer}{Layer to use (\code{"asinh"}, \code{"scale.data"}, \code{"data"}, \code{"counts"}).}

\item{boundaries}{One of \code{"segmentation"} or \code{"centroids"}.}

\item{combine}{Composite mode: \code{"max"}, \code{"mean"}, \code{"sum"}, \code{"rgb"}, \code{"stack"}.}

\item{normalize}{Either \code{"none"} or \code{"minmax"} (per-feature).}

\item{transform}{Either \code{"none"}, \code{"log1p"}, \code{"sqrt"}.}

\item{pt_size}{Point size for centroid mode (ignored for segmentation polygons).}

\item{alpha}{Alpha for non-\code{"stack"} composites.}

\item{colors}{Optional colours for \code{"stack"} mode; a \emph{named} vector (names == \code{features}) is recommended.}

\item{alpha_range}{For \code{"stack"}: \code{c(min, max)} alpha; defaults to \code{c(0, alpha)}.}

\item{stack_rescale_alpha_by_n}{If \code{TRUE}, reduces the maximum alpha by \code{length(features)}.}

\item{stack_alpha_gamma}{Gamma exponent for alpha scaling in \code{"stack"}.}

\item{limits}{Optional numeric limits passed to the continuous colour/fill scale.}

\item{export_path}{Optional file path for \code{ggplot2::ggsave}; returns the plot invisibly after saving.
The file type is inferred from the extension; output size is \code{(image_width / dpi) × (image_height / dpi)} inches.}

\item{dpi}{DPI for export when \code{export_path} is used.}

\item{verbose}{Logical; emit progress messages.}

\item{rebuild_seg_if_missing}{Try rebuilding segmentation from the mask if not found (needs \pkg{terra} and \pkg{sf}).}

\item{spatial_rotate_k}{Integer in \{0,1,2,3\}; rotate coordinates by 90°\eqn{\times k}.}

\item{rotate_center}{Optional numeric length‑2 vector \code{c(cx, cy)} for rotation center.}
}
\value{
A \code{ggplot} object (printed normally; returned invisibly if \code{export_path} is used).
}
\description{
Overlays cell intensities onto the MCDV mask/background image using either
segmentation polygons or centroids. Supports composite modes
(\code{"max"}, \code{"mean"}, \code{"sum"}, \code{"rgb"}, \code{"stack"})
and an optional visualization-only rotation like the loader.
}
\details{
\strong{Data path:}
The matrix is taken from the requested \code{layer}. If that layer is absent,
the function chooses the first available layer from
\code{c("asinh","scale.data","data","counts")} and, when \code{verbose = TRUE},
emits a message indicating the fallback.

\strong{Transform/normalize order:}
Values are transformed first (via \code{transform = "log1p"} or \code{"sqrt"}), then
optionally min–max normalized \emph{per feature across cells}
(\code{normalize = "minmax"}), and finally aggregated by \code{combine}.
For \code{combine = "rgb"}, each of the three features is independently
rescaled to 0,1 before composing \eqn{rgb(r,g,b, alpha)}.

\strong{Mask discovery:}
The background image path (\code{cell_mask_path}) is discovered in this order:
\enumerate{
\item \code{SeuratObject::Tool(obj, "LoadIMCSegmented")$paths$cell_mask_path}
\item \code{SeuratObject::Tool(obj)$LoadIMCSegmented$paths$cell_mask_path} (nested legacy)
\item \code{SeuratObject::Tool(obj)$paths$cell_mask_path} (flat legacy)
\item \code{obj@misc$paths$cell_mask_path}
\item \code{obj[[]]$cell_mask_path} (meta fallback; first non-NA)
}
The image dimensions determine the plotting canvas and the size used when exporting.

\strong{Segmentation rebuild (optional):}
If \code{boundaries = "segmentation"} but polygons are missing, setting
\code{rebuild_seg_if_missing = TRUE} attempts to rebuild them from the mask.
This requires the \pkg{terra} and \pkg{sf} packages to be installed.

\strong{Stack colours:}
For centroids, \code{combine = "stack"} uses \code{scale_color_manual()}; for segmentation
it uses \code{scale_fill_manual()}. Provide a \emph{named} vector \code{colors}
(names must match \code{features}) to guarantee the mapping.

\strong{Rotation center:}
The rotation center is taken from \code{rotate_center} when provided;
otherwise from the loader tool's stored center; otherwise the image center.
}
\examples{
\dontrun{
# Build per-FOV Seurat objects (requires Seurat v5, SeuratObject v5)
objs <- LoadIMCSegmented(
  top_dir = "~/Workspace_008",
  keep_unlabeled_channels = FALSE,
  add_asinh_layer = TRUE,
  build_segmentation_from_mask = TRUE,   # needs terra/sf if TRUE
  verbose = TRUE
)

fov <- objs[[1]]
# Choose a couple of features from the IMC assay
feats2 <- rownames(fov[["IMC"]])[1:2]
feats3 <- rownames(fov[["IMC"]])[1:3]

# Centroids overlay, continuous composite (max) from counts layer
p1 <- IMCFovPlot(
  fov,
  features   = feats2,
  assay      = "IMC",
  layer      = "counts",
  boundaries = "centroids",
  combine    = "max",
  normalize  = "minmax",
  spatial_rotate_k = 0L
)
print(p1)

# Segmentation overlay (sum) from asinh layer, rotated 90 degrees
p2 <- IMCFovPlot(
  fov,
  features   = feats2,
  assay      = "IMC",
  layer      = "asinh",
  boundaries = "segmentation",
  combine    = "sum",
  spatial_rotate_k = 1L
)
print(p2)

# RGB composite (exactly 3 features)
p3 <- IMCFovPlot(
  fov,
  features   = feats3,   # R,G,B in order
  assay      = "IMC",
  layer      = "asinh",
  boundaries = "centroids",
  combine    = "rgb"
)
print(p3)

# Save a stack composite to disk
IMCFovPlot(
  fov,
  features   = feats2,
  assay      = "IMC",
  boundaries = "centroids",
  combine    = "stack",
  export_path = tempfile(fileext = ".png"),
  dpi = 300
)
}
}
\seealso{
\code{\link{LoadIMCSegmented}}
}
\author{
Meredith A. Carpenter
}
